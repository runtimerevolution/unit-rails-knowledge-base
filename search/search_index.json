{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>index</p>"},{"location":"snippets/active_record/Or_precedence/","title":"Or precedence","text":""},{"location":"snippets/active_record/Or_precedence/#or-precedence","title":"OR Precedence","text":"<p>A problem with the activerecord is that usage of OR relies on natural precedence of OR and AND. So, the following query <pre><code>Order.joins(:address)\n.where(addresses: {state: 'TX'})\n.where('amount &lt; ?', 40)\n.or(\nOrder.where('amount &gt; ?', 100)\n)\n.order('orders.id')\n</code></pre> generates this SQL. <pre><code>SELECT *\nFROM \"orders\"\nINNER JOIN \"addresses\" ON \"addresses\".\"order_id\" = \"orders\".\"id\"\nWHERE (\"addresses\".\"state\" = \"TX\" AND (orders.amount &lt; 40)\nOR  orders.amount &gt; 100)\nORDER BY orders.id\n</code></pre> This will return all orders whose address is on Texas and have amounts less than 40 OR all orders with amount over 100 (indepedently of their address).</p> <p>But, what if we need to ensure the precedence of OR on the query? For our example, how do we make it so that we return all orders from Texas with amount either less than 40 or grater than 100?</p> <p>The solution is to use the <code>merge</code> method: <pre><code>Order.joins(:address)\n.where(addresses: {state: 'TX'})\n.merge(Order.where('orders.amount &lt; ?', 40)\n.or(Order.where('orders.amount &gt; ?', 100))\n.order('orders.id')\n</code></pre> and this will produce: <pre><code>SELECT *\nFROM orders\nINNER JOIN addresses on addresses.order_id = orders.id\nWHERE addresses.state = 'TX' AND (orders.amount &lt; 40 or orders.amount &gt; 100)\nORDER BY orders.id\n</code></pre></p> <p>Source: https://github.com/chrismo/activerecord_or_precedence</p>"},{"location":"snippets/active_record/above_7/explain/","title":"Explain","text":""},{"location":"snippets/active_record/above_7/explain/#explain","title":"Explain","text":"<p>Runs EXPLAIN on the query or queries triggered by this relation and returns the result as a string. The string is formatted imitating the ones printed by the database shell.</p> <p>Note that this method actually runs the queries, since the results of some are needed by the next ones when eager loading is going on.</p> <pre><code>Customer.where(active: true)\n.joins(:orders)\n.explain(:analyze, :verbose)\n</code></pre> <p>Note: <code>on rails 7.1</code> and above versions.</p>"},{"location":"snippets/ruby/hash_to_struct/","title":"Hash to struct","text":""},{"location":"snippets/ruby/hash_to_struct/#hash-to-struct","title":"Hash to Struct","text":"<pre><code># :Keyword_init forces Struct::new to take thyword ards instead of normal args\nUser = Struct.new(:email, :gid, :name, keyword_init: true)\n\n# you don't need to order the keys (:gid and :email are reserved)\nuser_hash = {\ngid: \"nhg-123-fd3-Eee\",\nemail: \"rails-unit@runtime-revolution.com\",\nname: \"Rails Unit\"\n}\n\nuser = User.new(user_hash)\n\nuser # =&gt; #&lt;struct User email: ... &gt;\n</code></pre> <p><code>Source</code>: https://www.rubycademy.com/cards/hash-to-struct</p>"}]}